package leetCode;

/**
 * 给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。
 * <p>
 * 换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] < nums[i] 。
 * <p>
 * 以数组形式返回答案。
 * <p>
 * 提示：
 * 2 <= nums.length <= 500
 * 0 <= nums[i] <= 100 (计数排序)
 * <p>
 * 计数排序(Counting sort)
 * 计数排序(Counting sort)是一种稳定的排序算法。计数排序是最简单的特例，
 * 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），
 * 这使得计数排序对于数据范围很大的数组，需要大量时间和内存，适用性不高。
 * 例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。
 * 但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。
 * 当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。
 * 算法的步骤如下：
 * <p>
 * 找出待排序的数组中最大和最小的元素
 * 统计数组中每个值为t的元素出现的次数，存入数组C的第t项
 * 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
 * 反向填充目标数组：将每个元素t放在新数组的第C(t)项，每放一个元素就将C(t)减去1
 * <p>
 * 计数排序(Counting sort)
 * 计数排序(Counting sort)是一种稳定的排序算法。计数排序是最简单的特例，
 * 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），
 * 这使得计数排序对于数据范围很大的数组，需要大量时间和内存，适用性不高。
 * 例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。
 * 但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。
 * 当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。
 * 算法的步骤如下：
 * <p>
 * 找出待排序的数组中最大和最小的元素
 * 统计数组中每个值为t的元素出现的次数，存入数组C的第t项
 * 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
 * 反向填充目标数组：将每个元素t放在新数组的第C(t)项，每放一个元素就将C(t)减去1
 * <p>
 * 计数排序(Counting sort)
 * 计数排序(Counting sort)是一种稳定的排序算法。计数排序是最简单的特例，
 * 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），
 * 这使得计数排序对于数据范围很大的数组，需要大量时间和内存，适用性不高。
 * 例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。
 * 但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。
 * 当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。
 * 算法的步骤如下：
 * <p>
 * 找出待排序的数组中最大和最小的元素
 * 统计数组中每个值为t的元素出现的次数，存入数组C的第t项
 * 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
 * 反向填充目标数组：将每个元素t放在新数组的第C(t)项，每放一个元素就将C(t)减去1
 */

/**
 * 计数排序(Counting sort)
 *     计数排序(Counting sort)是一种稳定的排序算法。计数排序是最简单的特例，
 *     由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），
 *     这使得计数排序对于数据范围很大的数组，需要大量时间和内存，适用性不高。
 *     例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。
 *     但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。
 *     当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。
 *  算法的步骤如下：
 *
 * 找出待排序的数组中最大和最小的元素
 * 统计数组中每个值为t的元素出现的次数，存入数组C的第t项
 * 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
 * 反向填充目标数组：将每个元素t放在新数组的第C(t)项，每放一个元素就将C(t)减去1
 */

/**
 * 桶排序（Bucket Sort）
 *     首先定义桶，桶为一个数据容器，每个桶存储一个区间内的数。依然有一个待排序的整数序列A，元素的最小值不小于0，最大值不超过K。假设我们有M个桶，第i个桶Bucket[i]存储i*K/M至(i+1)*K/M之间的数。桶排序步骤如下：
 *
 * 扫描序列A，根据每个元素的值所属的区间，放入指定的桶中(顺序放置)。
 * 对每个桶中的元素进行排序，什么排序算法都可以，例如插入排序。
 * 依次收集每个桶中的元素，顺序放置到输出序列中。
 */
public class Solution1365 {
    /**
     * 位图法
     * @param nums
     * @return
     */
    public static int[] smallerNumbersThanCurrent0(int[] nums) {
        int[] res = new int[nums.length];
        int[] bitMap = new int[501];
        for (int i : nums) {
            bitMap[i]++;
        }
        int n = 0;
        for (int i : nums) {
            for (int j = i - 1; j >= 0; j--) {
                res[n] += bitMap[j];
            }
            n++;
        }
        return res;
    }

    /**
     * 计数排序/
     * @param nums
     * @return
     */
    public static int[] smallerNumbersThanCurrent(int[] nums) {
        int[] res = new int[nums.length];
        int[] bitMap = new int[101];
        for (int i : nums) {
            bitMap[i]++;
        }
        for (int i = 1; i < bitMap.length; i++) {
            bitMap[i] += bitMap[i - 1];
        }
        for (int i = 0; i < nums.length; i++) {
           if (nums[i]>0){
               res[i] = bitMap[nums[i]-1];
           }
        }
        return res;
    }


    public static void main(String[] args) {
        int[] nums = {8, 1, 2, 2, 3};
        System.out.println(smallerNumbersThanCurrent(nums));
    }
}
